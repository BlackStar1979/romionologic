name: Deploy to Neocities

on:
  push:
    branches: [ main ]
    paths:
      - '**/*.html'
      - '**/*.css'
      - '**/*.js'
      - 'assets/**'
      - 'sim/**'
      - 'examples/**'
      - 'index.html'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

concurrency:
  group: neocities-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) Lint + canonical injection (zgodnie z Twoim standardem, bez trailing '/')
      - name: Lint & inject canonical links
        shell: bash
        run: |
          set -euo pipefail
          BASE_URL="https://romionologic.neocities.org"

          python3 - << 'PY'
import os, re, sys, subprocess
BASE_URL = "https://romionologic.neocities.org"

# znajdź wszystkie .html poza assets/, examples/ i katalogami ukrytymi
html_files = []
for root, dirs, files in os.walk(".", topdown=True):
    # pomiń ukryte katalogi i techniczne
    dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ('.git', '.github', 'assets', 'examples')]
    for f in files:
        if f.endswith(".html"):
            html_files.append(os.path.join(root, f))

# helpery
def canonical_for(path):
    p = path.replace("\\","/")
    if p == "./index.html" or p == "index.html":
        return "/"
    if p.endswith("/index.html"):
        d = p[:-len("index.html")]
        d = d[2:] if d.startswith("./") else d
        if d.endswith("/"): d = d[:-1]
        return "/" + d
    p = p[2:] if p.startswith("./") else p
    if p.lower().endswith(".html"):
        p = p[:-5]
    return "/" + p

def git_lastmod(p):
    try:
        out = subprocess.check_output(["git","log","-1","--format=%cI","--",p], stderr=subprocess.DEVNULL).decode().strip()
        return out if out else None
    except Exception:
        return None

# 1) lint: kolizje plik vs katalog
errors = []
# zbuduj zbiory baz (bez .html) i katalogów z index.html
files_noext = set()
dirs_with_index = set()
for p in html_files:
    up = p.replace("\\","/")
    if up.endswith("/index.html"):
        b = up[:-len("/index.html")]
        b = b[2:] if b.startswith("./") else b
        dirs_with_index.add(b.lower())
    elif up.endswith(".html"):
        b = up[2:] if up.startswith("./") else up
        b = b[:-5]
        files_noext.add(b.lower())

# konflikt: jednocześnie x.html i x/index.html
for b in sorted(files_noext & dirs_with_index):
    errors.append(f"Kolizja: istnieją jednocześnie './{b}.html' oraz './{b}/index.html' — usuń jedną z wersji.")

if errors:
    for e in errors:
        print(f"::error::{e}")
    sys.exit(1)

# 2) inject/update canonical dla każdego pliku
link_re = re.compile(r'<link\b[^>]*rel=[\'"]?canonical[\'"]?[^>]*>', re.IGNORECASE)
head_close_re = re.compile(r'</head\s*>', re.IGNORECASE)

updated = 0
for p in html_files:
    # pomiń techniczne/special
    low = p.lower()
    if any(x in low for x in ("/assets/", "/examples/")): 
        continue
    if any(low.endswith(x) for x in ("not_found.html","404.html","/404/index.html")):
        continue

    canon = canonical_for(p)
    full = BASE_URL + canon
    with open(p, "r", encoding="utf-8", errors="ignore") as f:
        html = f.read()

    # jeśli już jest canonical — podmień
    if link_re.search(html):
        new_link = f'<link rel="canonical" href="{full}">'
        html2 = link_re.sub(new_link, html)
    else:
        # wstrzyknij przed </head>, jeśli istnieje; jak nie ma, pomiń
        m = head_close_re.search(html)
        if not m:
            html2 = html
        else:
            new_link = f'  <link rel="canonical" href="{full}">\n'
            pos = m.start()
            html2 = html[:pos] + new_link + html[pos:]

    if html2 != html:
        with open(p, "w", encoding="utf-8") as f:
            f.write(html2)
        updated += 1

print(f"Zaktualizowano canonical w {updated} plikach.")
PY

      # 2) Sitemap zgodna z kanonem (bez trailing '/'), + wpis w robots.txt
      - name: Generate canonical sitemap.xml (+ ensure robots.txt has Sitemap)
        shell: bash
        run: |
          set -euo pipefail
          BASE_URL="https://romionologic.neocities.org"

          tmp_urls="$(mktemp)"
          declare -A seen
          add_url() { local u="$1"; if [[ -z "${seen[$u]+x}" ]]; then echo "$u" >> "$tmp_urls"; seen[$u]=1; fi }

          # katalogi z index.html => /sciezka  (root => /)
          while IFS= read -r idx; do
            dir="${idx%index.html}"; dir="${dir#./}"
            if [[ -z "$dir" ]]; then add_url "/"; else dir="${dir%/}"; add_url "/$dir"; fi
          done < <(find . -type f -name 'index.html' ! -path './assets/*' ! -path './examples/*' ! -path './.*' | sort)

          # pliki .html (bez index.html) => /nazwa
          while IFS= read -r f; do
            base="${f#./}"; base="${base%.html}"
            case "$base" in 404|404/index|not_found|sim_old) continue ;; esac
            add_url "/$base"
          done < <(find . -type f -name '*.html' ! -name 'index.html' ! -path './assets/*' ! -path './examples/*' ! -path './.*' | sort)

          # zbuduj sitemap.xml
          {
            echo '<?xml version="1.0" encoding="UTF-8"?>'
            echo '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">'
            while IFS= read -r path; do
              if [[ "$path" == "/" ]]; then src="./index.html"
              else p="${path#/}"; if [[ -f "./$p/index.html" ]]; then src="./$p/index.html"; elif [[ -f "./$p.html" ]]; then src="./$p.html"; else src="./$p"; fi; fi
              lastmod="$(git log -1 --format=%cI -- "$src" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")"
              printf '  <url>\n    <loc>%s%s</loc>\n    <lastmod>%s</lastmod>\n  </url>\n' "$BASE_URL" "$path" "$lastmod"
            done < <(sort -u "$tmp_urls")
            echo '</urlset>'
          } > sitemap.xml

          # dopisz Sitemap do robots.txt (jeśli brak)
          if [[ -f robots.txt ]]; then
            grep -qi '^sitemap:' robots.txt || echo "Sitemap: $BASE_URL/sitemap.xml" >> robots.txt
          else
            printf 'User-agent: *\nAllow: /\nSitemap: %s/sitemap.xml\n' "$BASE_URL" > robots.txt
          fi

          rm -f "$tmp_urls"

      # 3) Usuń rzeczy, których nie chcemy wgrywać
      - name: Remove files that must NOT be uploaded
        run: |
          rm -rf .git .github .gitignore .gitattributes

      # 4) Deploy
      - name: Deploy to Neocities
        uses: bcomnes/deploy-to-neocities@v2
        with:
          api_token: ${{ secrets.NEOCITIES_API_TOKEN }}
          dist_dir: .
          cleanup: false
          protected_files: |
            favicon.svg
            favicon.ico
name: Deploy to Neocities

on:
  push:
    branches: [ main ]
    paths:
      - '**/*.html'
      - '**/*.css'
      - '**/*.js'
      - 'assets/**'
      - 'sim/**'
      - 'examples/**'
      - 'index.html'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:

concurrency:
  group: neocities-deploy
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      # 1) Lint + canonical injection (zgodnie z Twoim standardem, bez trailing '/')
      - name: Lint & inject canonical links
        shell: bash
        run: |
          set -euo pipefail
          BASE_URL="https://romionologic.neocities.org"

          python3 - << 'PY'
import os, re, sys, subprocess
BASE_URL = "https://romionologic.neocities.org"

# znajdź wszystkie .html poza assets/, examples/ i katalogami ukrytymi
html_files = []
for root, dirs, files in os.walk(".", topdown=True):
    # pomiń ukryte katalogi i techniczne
    dirs[:] = [d for d in dirs if not d.startswith('.') and d not in ('.git', '.github', 'assets', 'examples')]
    for f in files:
        if f.endswith(".html"):
            html_files.append(os.path.join(root, f))

# helpery
def canonical_for(path):
    p = path.replace("\\","/")
    if p == "./index.html" or p == "index.html":
        return "/"
    if p.endswith("/index.html"):
        d = p[:-len("index.html")]
        d = d[2:] if d.startswith("./") else d
        if d.endswith("/"): d = d[:-1]
        return "/" + d
    p = p[2:] if p.startswith("./") else p
    if p.lower().endswith(".html"):
        p = p[:-5]
    return "/" + p

def git_lastmod(p):
    try:
        out = subprocess.check_output(["git","log","-1","--format=%cI","--",p], stderr=subprocess.DEVNULL).decode().strip()
        return out if out else None
    except Exception:
        return None

# 1) lint: kolizje plik vs katalog
errors = []
# zbuduj zbiory baz (bez .html) i katalogów z index.html
files_noext = set()
dirs_with_index = set()
for p in html_files:
    up = p.replace("\\","/")
    if up.endswith("/index.html"):
        b = up[:-len("/index.html")]
        b = b[2:] if b.startswith("./") else b
        dirs_with_index.add(b.lower())
    elif up.endswith(".html"):
        b = up[2:] if up.startswith("./") else up
        b = b[:-5]
        files_noext.add(b.lower())

# konflikt: jednocześnie x.html i x/index.html
for b in sorted(files_noext & dirs_with_index):
    errors.append(f"Kolizja: istnieją jednocześnie './{b}.html' oraz './{b}/index.html' — usuń jedną z wersji.")

if errors:
    for e in errors:
        print(f"::error::{e}")
    sys.exit(1)

# 2) inject/update canonical dla każdego pliku
link_re = re.compile(r'<link\b[^>]*rel=[\'"]?canonical[\'"]?[^>]*>', re.IGNORECASE)
head_close_re = re.compile(r'</head\s*>', re.IGNORECASE)

updated = 0
for p in html_files:
    # pomiń techniczne/special
    low = p.lower()
    if any(x in low for x in ("/assets/", "/examples/")): 
        continue
    if any(low.endswith(x) for x in ("not_found.html","404.html","/404/index.html")):
        continue

    canon = canonical_for(p)
    full = BASE_URL + canon
    with open(p, "r", encoding="utf-8", errors="ignore") as f:
        html = f.read()

    # jeśli już jest canonical — podmień
    if link_re.search(html):
        new_link = f'<link rel="canonical" href="{full}">'
        html2 = link_re.sub(new_link, html)
    else:
        # wstrzyknij przed </head>, jeśli istnieje; jak nie ma, pomiń
        m = head_close_re.search(html)
        if not m:
            html2 = html
        else:
            new_link = f'  <link rel="canonical" href="{full}">\n'
            pos = m.start()
            html2 = html[:pos] + new_link + html[pos:]

    if html2 != html:
        with open(p, "w", encoding="utf-8") as f:
            f.write(html2)
        updated += 1

print(f"Zaktualizowano canonical w {updated} plikach.")
PY

      # 2) Sitemap zgodna z kanonem (bez trailing '/'), + wpis w robots.txt
      - name: Generate canonical sitemap.xml (+ ensure robots.txt has Sitemap)
        shell: bash
        run: |
          set -euo pipefail
          BASE_URL="https://romionologic.neocities.org"

          tmp_urls="$(mktemp)"
          declare -A seen
          add_url() { local u="$1"; if [[ -z "${seen[$u]+x}" ]]; then echo "$u" >> "$tmp_urls"; seen[$u]=1; fi }

          # katalogi z index.html => /sciezka  (root => /)
          while IFS= read -r idx; do
            dir="${idx%index.html}"; dir="${dir#./}"
            if [[ -z "$dir" ]]; then add_url "/"; else dir="${dir%/}"; add_url "/$dir"; fi
          done < <(find . -type f -name 'index.html' ! -path './assets/*' ! -path './examples/*' ! -path './.*' | sort)

          # pliki .html (bez index.html) => /nazwa
          while IFS= read -r f; do
            base="${f#./}"; base="${base%.html}"
            case "$base" in 404|404/index|not_found|sim_old) continue ;; esac
            add_url "/$base"
          done < <(find . -type f -name '*.html' ! -name 'index.html' ! -path './assets/*' ! -path './examples/*' ! -path './.*' | sort)

          # zbuduj sitemap.xml
          {
            echo '<?xml version="1.0" encoding="UTF-8"?>'
            echo '<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">'
            while IFS= read -r path; do
              if [[ "$path" == "/" ]]; then src="./index.html"
              else p="${path#/}"; if [[ -f "./$p/index.html" ]]; then src="./$p/index.html"; elif [[ -f "./$p.html" ]]; then src="./$p.html"; else src="./$p"; fi; fi
              lastmod="$(git log -1 --format=%cI -- "$src" 2>/dev/null || date -u +"%Y-%m-%dT%H:%M:%SZ")"
              printf '  <url>\n    <loc>%s%s</loc>\n    <lastmod>%s</lastmod>\n  </url>\n' "$BASE_URL" "$path" "$lastmod"
            done < <(sort -u "$tmp_urls")
            echo '</urlset>'
          } > sitemap.xml

          # dopisz Sitemap do robots.txt (jeśli brak)
          if [[ -f robots.txt ]]; then
            grep -qi '^sitemap:' robots.txt || echo "Sitemap: $BASE_URL/sitemap.xml" >> robots.txt
          else
            printf 'User-agent: *\nAllow: /\nSitemap: %s/sitemap.xml\n' "$BASE_URL" > robots.txt
          fi

          rm -f "$tmp_urls"

      # 3) Usuń rzeczy, których nie chcemy wgrywać
      - name: Remove files that must NOT be uploaded
        run: |
          rm -rf .git .github .gitignore .gitattributes

      # 4) Deploy
      - name: Deploy to Neocities
        uses: bcomnes/deploy-to-neocities@v2
        with:
          api_token: ${{ secrets.NEOCITIES_API_TOKEN }}
          dist_dir: .
          cleanup: false
          protected_files: |
            favicon.svg
            favicon.ico
